# Анализ логики выбора лучшего месяца и предложения по улучшению

## Краткое резюме

**Проблема:** Текущий алгоритм использует **вертикальный ранг** (сравнение КМ между собой), что некорректно для задачи выбора лучшего месяца у конкретного КМ.

**Решение:** Использовать **горизонтальный ранг** (сравнение месяцев у конкретного КМ) с параметром `best_direction` (MAX или MIN).

**Преимущества:**
- ✅ Корректно определяет лучший месяц для каждого КМ
- ✅ Учитывает направление показателя (больше = лучше или меньше = лучше)
- ✅ Проще в реализации и понимании
- ✅ Быстрее в выполнении

**Рекомендация:** Внедрить новый алгоритм с горизонтальным рангом.

---

## Текущая логика

### Шаг 1: Расчет показателей по месяцам
Для каждого КМ (табельного номера) рассчитываются 3 показателя (OD, RA, PS) для каждого месяца:
- **OD (M-X)**: значение показателя OD в месяце X (может быть: факт, прирост по 2 месяцам, прирост по 3 периодам)
- **RA (M-X)**: значение показателя RA в месяце X (может быть: факт, прирост по 2 месяцам, прирост по 3 периодам)
- **PS (M-X)**: значение показателя PS в месяце X (может быть: факт, прирост по 2 месяцам, прирост по 3 периодам)

**Важно:** Каждый показатель (OD, RA, PS) может иметь свой тип расчета для каждого месяца, задаваемый в конфигурации через параметр `calculation_type`:
- `calculation_type=1`: "Как есть" - просто факт (сумма данных по табельному в указанный месяц)
- `calculation_type=2`: "Прирост по 2 месяцам" - текущий месяц - предыдущий месяц
- `calculation_type=3`: "Прирост по трем периодам" - М-N = М-N - 2*М-(N-1) + М-(N-2)

### Шаг 2: Расчет вертикальных рангов
Для каждого показателя в каждом месяце рассчитывается **вертикальный ранг** (среди всех КМ):
- **R: OD (M-X)**: ранг КМ по показателю OD в месяце X (среди всех КМ)
- **R: RA (M-X)**: ранг КМ по показателю RA в месяце X (среди всех КМ)
- **R: PS (M-X)**: ранг КМ по показателю PS в месяце X (среди всех КМ)

**Проблема:** Ранг считается **вертикально** (среди всех КМ), но для выбора лучшего месяца у конкретного КМ нужен **горизонтальный ранг** (среди месяцев у этого КМ).

### Шаг 3: Расчет итогового ранга R_FIN
Для каждого месяца рассчитывается взвешенная сумма рангов:
```
R_FIN (M-X) = R: OD (M-X) * weight_OD + R: RA (M-X) * weight_RA + R: PS (M-X) * weight_PS
```

### Шаг 4: Выбор лучшего месяца
Для каждого КМ выбирается месяц с **минимальным** значением R_FIN.

**Проблема:** 
- R_FIN основан на вертикальных рангах (сравнение с другими КМ), а не на горизонтальных (сравнение месяцев у конкретного КМ)
- Не учитывается направление показателя (MAX или MIN) - всегда выбирается минимальный R_FIN

---

## Проблемы текущего подхода

### Проблема 1: Вертикальный ранг вместо горизонтального
**Пример:**
- КМ А: OD(M-1)=1000, OD(M-2)=2000
- КМ Б: OD(M-1)=500, OD(M-2)=1500

**Текущая логика:**
- R: OD (M-1): КМ А = 1, КМ Б = 2
- R: OD (M-2): КМ А = 1, КМ Б = 2
- R_FIN (M-1): КМ А = 0.33, КМ Б = 0.66
- R_FIN (M-2): КМ А = 0.33, КМ Б = 0.66
- **Лучший месяц:** КМ А = M-1 или M-2 (одинаково), КМ Б = M-1 или M-2 (одинаково)

**Проблема:** Для КМ А лучший месяц должен быть M-2 (2000 > 1000), но текущая логика не может это определить, так как сравнивает с другими КМ, а не с собственными результатами КМ А.

### Проблема 2: Не учитывается направление показателя
- Если показатель "чем больше, тем лучше" (MAX), нужно выбирать месяц с максимальным значением
- Если показатель "чем меньше, тем лучше" (MIN), нужно выбирать месяц с минимальным значением
- Текущая логика всегда выбирает минимальный R_FIN, что не всегда корректно

### Проблема 3: Разные масштабы показателей
- OD может быть в диапазоне 0-10000
- RA может быть в диапазоне 0-5000
- PS может быть в диапазоне 0-3000

При прямом суммировании показатели с большими значениями будут доминировать.

---

## Предлагаемые решения

### Вариант 1: Горизонтальный ранг для каждого КМ (РЕКОМЕНДУЕТСЯ)

**Идея:** Для каждого КМ рассчитывать ранг **по месяцам** (горизонтально), а не среди всех КМ (вертикально).

**Алгоритм:**
1. Для каждого КМ и каждого месяца рассчитываем взвешенную сумму **значений показателей**:
   ```
   Score(M-X) = OD(M-X) * weight_OD + RA(M-X) * weight_RA + PS(M-X) * weight_PS
   ```
2. Для каждого КМ рассчитываем **горизонтальный ранг** по месяцам:
   - Если `best_direction = "MAX"`: ранг 1 = месяц с максимальным Score
   - Если `best_direction = "MIN"`: ранг 1 = месяц с минимальным Score
3. Выбираем месяц с рангом 1 для каждого КМ

**Преимущества:**
- ✅ Сравниваем месяцы у конкретного КМ, а не КМ между собой
- ✅ Учитываем направление показателя (MAX или MIN)
- ✅ Не нужна нормализация показателей (сравниваем только месяцы одного КМ)
- ✅ Логика проще и понятнее

**Недостатки:**
- ⚠️ Теряется информация о том, как КМ выглядит на фоне других (но это не нужно для выбора лучшего месяца)

**Пример:**
```
КМ А:
  M-1: OD=1000, RA=500, PS=300  → Score = 1000*0.33 + 500*0.33 + 300*0.34 = 495
  M-2: OD=2000, RA=800, PS=400  → Score = 2000*0.33 + 800*0.33 + 400*0.34 = 990
  M-3: OD=1500, RA=600, PS=350  → Score = 1500*0.33 + 600*0.33 + 350*0.34 = 742.5

Горизонтальный ранг (MAX): M-2 = 1, M-3 = 2, M-1 = 3
Лучший месяц: M-2 ✅
```

---

### Вариант 2: Нормализация + взвешенная сумма

**Идея:** Нормализовать показатели перед суммированием, затем выбрать лучший месяц по взвешенной сумме.

**Алгоритм:**
1. Для каждого показателя нормализуем значения по месяцам для каждого КМ:
   ```
   OD_norm(M-X) = (OD(M-X) - min(OD)) / (max(OD) - min(OD))  [для MAX]
   OD_norm(M-X) = (max(OD) - OD(M-X)) / (max(OD) - min(OD))  [для MIN]
   ```
2. Рассчитываем взвешенную сумму нормализованных значений:
   ```
   Score(M-X) = OD_norm(M-X) * weight_OD + RA_norm(M-X) * weight_RA + PS_norm(M-X) * weight_PS
   ```
3. Выбираем месяц с максимальным Score (после нормализации всегда MAX)

**Преимущества:**
- ✅ Учитывает направление показателя (MAX или MIN)
- ✅ Нормализация устраняет проблему разных масштабов
- ✅ Прямое сравнение значений, без рангов

**Недостатки:**
- ⚠️ Сложнее в реализации (нужна нормализация)
- ⚠️ Если у КМ только один месяц с данными, нормализация не работает (деление на 0)

---

### Вариант 3: Горизонтальный ранг по нормализованным значениям (РАСШИРЕННЫЙ)

**Идея:** Комбинация вариантов 1 и 2 - нормализация + горизонтальный ранг, с учетом **разных направлений для каждого показателя** и **разных типов расчета**.

**Ключевая особенность:** Каждый показатель (OD, RA, PS) может иметь свое направление (MAX или MIN) и свой тип расчета (факт, прирост по 2м, прирост по 3м).

**Алгоритм:**
1. Для каждого КМ нормализуем показатели по месяцам с учетом направления каждого показателя
2. Рассчитываем взвешенную сумму нормализованных значений
3. Рассчитываем горизонтальный ранг по Score для каждого КМ
4. Выбираем месяц с рангом 1

**Преимущества:**
- ✅ Учитывает **разные направления** для каждого показателя (OD=MAX, RA=MIN, PS=MAX)
- ✅ Нормализация устраняет проблему разных масштабов (факт=10000, прирост=-500)
- ✅ Горизонтальный ранг делает выбор более устойчивым
- ✅ Учитывает разные типы расчета (факт, прирост по 2м, прирост по 3м)

**Недостатки:**
- ⚠️ Сложнее в реализации (нужна нормализация с учетом направления)
- ⚠️ Проблема с одним месяцем (но можно обработать)
- ⚠️ Требует дополнительных параметров конфигурации (направление для каждого показателя)

---

## Детальный алгоритм Варианта 3 (с учетом разных направлений)

### Шаг 1: Нормализация показателей с учетом направления

**Для каждого КМ и каждого показателя:**

```python
# Параметры из конфигурации:
# - OD: direction="MAX", calculation_type=3 (прирост по 3м)
# - RA: direction="MIN", calculation_type=2 (прирост по 2м)
# - PS: direction="MAX", calculation_type=1 (факт)

for km in all_km:
    # Нормализация OD (direction="MAX")
    od_values = [OD(M-1), OD(M-2), ..., OD(M-12)]  # Только месяцы с данными
    od_min = min(od_values)
    od_max = max(od_values)
    
    if od_max != od_min:
        # Для MAX: большее значение = лучше, нормализуем к [0, 1]
        od_norm = {
            month: (OD(month) - od_min) / (od_max - od_min)
            for month in months_with_data
        }
    else:
        # Все значения одинаковы
        od_norm = {month: 0.5 for month in months_with_data}
    
    # Нормализация RA (direction="MIN")
    ra_values = [RA(M-1), RA(M-2), ..., RA(M-12)]  # Только месяцы с данными
    ra_min = min(ra_values)
    ra_max = max(ra_values)
    
    if ra_max != ra_min:
        # Для MIN: меньшее значение = лучше, инвертируем нормализацию
        ra_norm = {
            month: (ra_max - RA(month)) / (ra_max - ra_min)
            for month in months_with_data
        }
    else:
        # Все значения одинаковы
        ra_norm = {month: 0.5 for month in months_with_data}
    
    # Нормализация PS (direction="MAX")
    ps_values = [PS(M-1), PS(M-2), ..., PS(M-12)]  # Только месяцы с данными
    ps_min = min(ps_values)
    ps_max = max(ps_values)
    
    if ps_max != ps_min:
        # Для MAX: большее значение = лучше, нормализуем к [0, 1]
        ps_norm = {
            month: (PS(month) - ps_min) / (ps_max - ps_min)
            for month in months_with_data
        }
    else:
        # Все значения одинаковы
        ps_norm = {month: 0.5 for month in months_with_data}
```

**Важно:** 
- После нормализации все показатели находятся в диапазоне [0, 1]
- Для MAX: большее значение → большее нормализованное значение (ближе к 1)
- Для MIN: меньшее значение → большее нормализованное значение (ближе к 1) - инверсия!

### Шаг 2: Расчет взвешенной суммы нормализованных значений

```python
# Для каждого КМ и каждого месяца
for km in all_km:
    for month in months_with_data:
        score = (
            od_norm[month] * weight_OD + 
            ra_norm[month] * weight_RA + 
            ps_norm[month] * weight_PS
        )
        scores[km][month] = score
```

**Результат:** Score всегда в диапазоне [0, 1], где большее значение = лучше (после нормализации все показатели направлены "больше = лучше").

### Шаг 3: Расчет горизонтального ранга

```python
# Для каждого КМ
for km in all_km:
    km_scores = scores[km]  # Словарь {month: score}
    
    # После нормализации всегда MAX (больше = лучше)
    sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
    
    # Присваиваем ранги (с учетом одинаковых значений)
    rank = 1
    prev_score = None
    for month, score in sorted_months:
        if prev_score is not None and abs(score - prev_score) > 1e-10:
            rank += 1
        ranks[km][month] = rank
        prev_score = score
```

### Шаг 4: Выбор лучшего месяца

```python
# Для каждого КМ выбираем месяц с рангом 1
for km in all_km:
    best_months = [month for month, rank in ranks[km].items() if rank == 1]
    best_month[km] = ", ".join(sorted(best_months))
```

---

## Пример работы Варианта 3

### Исходные данные

**КМ А:**
| Месяц | OD (прирост по 3м, MAX) | RA (прирост по 2м, MIN) | PS (факт, MAX) |
|-------|-------------------------|-------------------------|----------------|
| M-1   | 1000                    | 500                     | 300            |
| M-2   | 2000                    | 300                     | 400            |
| M-3   | -500                    | 800                     | 350            |
| M-4   | 1500                    | 200                     | 380            |

**Веса:** OD=0.33, RA=0.33, PS=0.34

**Направления:** OD=MAX, RA=MIN, PS=MAX

### Шаг 1: Нормализация с учетом направления

**OD (MAX):**
```
OD: M-1=1000, M-2=2000, M-3=-500, M-4=1500
min = -500, max = 2000
OD_norm(M-1) = (1000 - (-500)) / (2000 - (-500)) = 1500/2500 = 0.60
OD_norm(M-2) = (2000 - (-500)) / (2000 - (-500)) = 2500/2500 = 1.00 ✅
OD_norm(M-3) = (-500 - (-500)) / (2000 - (-500)) = 0/2500 = 0.00
OD_norm(M-4) = (1500 - (-500)) / (2000 - (-500)) = 2000/2500 = 0.80
```

**RA (MIN):**
```
RA: M-1=500, M-2=300, M-3=800, M-4=200
min = 200, max = 800
RA_norm(M-1) = (800 - 500) / (800 - 200) = 300/600 = 0.50
RA_norm(M-2) = (800 - 300) / (800 - 200) = 500/600 = 0.83
RA_norm(M-3) = (800 - 800) / (800 - 200) = 0/600 = 0.00
RA_norm(M-4) = (800 - 200) / (800 - 200) = 600/600 = 1.00 ✅ (меньше = лучше, инверсия!)
```

**PS (MAX):**
```
PS: M-1=300, M-2=400, M-3=350, M-4=380
min = 300, max = 400
PS_norm(M-1) = (300 - 300) / (400 - 300) = 0/100 = 0.00
PS_norm(M-2) = (400 - 300) / (400 - 300) = 100/100 = 1.00 ✅
PS_norm(M-3) = (350 - 300) / (400 - 300) = 50/100 = 0.50
PS_norm(M-4) = (380 - 300) / (400 - 300) = 80/100 = 0.80
```

### Шаг 2: Расчет Score

```
Score(M-1) = 0.60*0.33 + 0.50*0.33 + 0.00*0.34 = 0.198 + 0.165 + 0.000 = 0.363
Score(M-2) = 1.00*0.33 + 0.83*0.33 + 1.00*0.34 = 0.330 + 0.274 + 0.340 = 0.944 ✅
Score(M-3) = 0.00*0.33 + 0.00*0.33 + 0.50*0.34 = 0.000 + 0.000 + 0.170 = 0.170
Score(M-4) = 0.80*0.33 + 1.00*0.33 + 0.80*0.34 = 0.264 + 0.330 + 0.272 = 0.866
```

### Шаг 3: Горизонтальный ранг

```
Сортировка по убыванию Score:
  M-2: 0.944 (ранг 1) ✅
  M-4: 0.866 (ранг 2)
  M-1: 0.363 (ранг 3)
  M-3: 0.170 (ранг 4)
```

**Лучший месяц:** M-2 ✅

**Интерпретация:**
- M-2 имеет максимальный OD (прирост по 3м) ✅
- M-2 имеет минимальный RA (прирост по 2м) ✅ (меньше = лучше)
- M-2 имеет максимальный PS (факт) ✅

---

## Конфигурация для Варианта 3

### Параметры в DefaultsConfig

```python
@dataclass
class DefaultsConfig:
    # ... существующие параметры ...
    
    # Направление показателя для расчета лучшего месяца
    # "MAX" - большее значение лучше, "MIN" - меньшее значение лучше
    indicator_direction: str = "MAX"  # По умолчанию для всех показателей
    
    # Или можно задать для каждого показателя отдельно (если нужна гибкость):
    # od_direction: str = "MAX"
    # ra_direction: str = "MIN"
    # ps_direction: str = "MAX"
```

### Использование в конфигурации

```python
configs["OD"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=3,  # Прирост по 3 периодам
        indicator_direction="MAX",  # Больше = лучше
        weight=0.33,
        ...
    )
)

configs["RA"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=2,  # Прирост по 2 месяцам
        indicator_direction="MIN",  # Меньше = лучше (например, снижение долга)
        weight=0.33,
        ...
    )
)

configs["PS"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=1,  # Факт
        indicator_direction="MAX",  # Больше = лучше
        weight=0.34,
        ...
    )
)
```

---

## Сравнение вариантов с учетом разных направлений

| Критерий | Вариант 1 (без нормализации) | Вариант 3 (с нормализацией) |
|----------|------------------------------|----------------------------|
| **Разные направления** | ⚠️ Сложно (нужна инверсия значений) | ✅ Легко (инверсия в нормализации) |
| **Разные масштабы** | ⚠️ Проблема (факт=10000, прирост=-500) | ✅ Решено (нормализация) |
| **Разные типы расчета** | ✅ Работает | ✅ Работает |
| **Простота** | ✅ Просто | ⚠️ Сложнее |
| **Производительность** | ✅ Быстро | ⚠️ Медленнее (нормализация) |

---

## Рекомендация для Варианта 3

**Использовать Вариант 3, если:**
1. ✅ Показатели имеют **разные направления** (OD=MAX, RA=MIN, PS=MAX)
2. ✅ Показатели имеют **сильно разные масштабы** (факт=10000, прирост=-500)
3. ✅ Нужна **более устойчивая** оценка (нормализация устраняет влияние масштабов)

**Использовать Вариант 1, если:**
1. ✅ Все показатели имеют **одно направление** (все MAX или все MIN)
2. ✅ Показатели имеют **сопоставимые масштабы**
3. ✅ Нужна **простота и скорость**

---

## Реализация Варианта 3 (Python код)

```python
def calculate_best_month_variant3(calculated_df, config_manager):
    """
    Рассчитывает лучший месяц для каждого КМ на основе нормализованных значений.
    Учитывает разные направления для каждого показателя.
    
    Args:
        calculated_df: DataFrame с расчетными данными
        config_manager: Менеджер конфигурации
    
    Returns:
        Series с лучшими месяцами для каждого КМ
    """
    # Получаем веса и направления для каждого показателя
    od_config = config_manager.get_group_config("OD").defaults
    ra_config = config_manager.get_group_config("RA").defaults
    ps_config = config_manager.get_group_config("PS").defaults
    
    weight_od = od_config.weight
    weight_ra = ra_config.weight
    weight_ps = ps_config.weight
    
    od_direction = getattr(od_config, 'indicator_direction', 'MAX')
    ra_direction = getattr(ra_config, 'indicator_direction', 'MAX')
    ps_direction = getattr(ps_config, 'indicator_direction', 'MAX')
    
    # Группируем колонки по месяцам
    month_data = {}  # {month: {"OD": col_name, "RA": col_name, "PS": col_name}}
    
    for col in calculated_df.columns:
        if col in base_columns or col.startswith("R:"):
            continue
        
        match = re.search(r'^([A-Z]+)\s+\(M-(\d{1,2})\)', col)
        if match:
            group = match.group(1)
            month = int(match.group(2))
            
            if month not in month_data:
                month_data[month] = {}
            month_data[month][group] = col
    
    best_month_series = pd.Series("", index=calculated_df.index, dtype=str)
    
    for idx in calculated_df.index:
        # Собираем значения показателей по месяцам
        od_values = {}
        ra_values = {}
        ps_values = {}
        
        for month in sorted(month_data.keys()):
            od_col = month_data[month].get("OD")
            ra_col = month_data[month].get("RA")
            ps_col = month_data[month].get("PS")
            
            if od_col and od_col in calculated_df.columns:
                od_val = calculated_df.loc[idx, od_col]
                if pd.notna(od_val) and od_val != 0:
                    od_values[month] = float(od_val)
            
            if ra_col and ra_col in calculated_df.columns:
                ra_val = calculated_df.loc[idx, ra_col]
                if pd.notna(ra_val) and ra_val != 0:
                    ra_values[month] = float(ra_val)
            
            if ps_col and ps_col in calculated_df.columns:
                ps_val = calculated_df.loc[idx, ps_col]
                if pd.notna(ps_val) and ps_val != 0:
                    ps_values[month] = float(ps_val)
        
        # Нормализация с учетом направления
        od_norm = normalize_with_direction(od_values, od_direction)
        ra_norm = normalize_with_direction(ra_values, ra_direction)
        ps_norm = normalize_with_direction(ps_values, ps_direction)
        
        # Расчет Score для каждого месяца
        km_scores = {}
        all_months = set(od_values.keys()) | set(ra_values.keys()) | set(ps_values.keys())
        
        for month in all_months:
            score = 0.0
            if month in od_norm:
                score += od_norm[month] * weight_od
            if month in ra_norm:
                score += ra_norm[month] * weight_ra
            if month in ps_norm:
                score += ps_norm[month] * weight_ps
            km_scores[month] = score
        
        # Горизонтальный ранг (после нормализации всегда MAX)
        if len(km_scores) > 0:
            sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
            
            ranks = {}
            rank = 1
            prev_score = None
            
            for month, score in sorted_months:
                if prev_score is not None and abs(score - prev_score) > 1e-10:
                    rank += 1
                ranks[month] = rank
                prev_score = score
            
            best_months = [month for month, r in ranks.items() if r == 1]
            if best_months:
                best_month_series.loc[idx] = ", ".join([str(m) for m in sorted(best_months)])
    
    return best_month_series


def normalize_with_direction(values: Dict[int, float], direction: str) -> Dict[int, float]:
    """
    Нормализует значения с учетом направления.
    
    Args:
        values: Словарь {month: value}
        direction: "MAX" или "MIN"
    
    Returns:
        Словарь {month: normalized_value} в диапазоне [0, 1]
    """
    if len(values) == 0:
        return {}
    
    if len(values) == 1:
        # Только один месяц - возвращаем 0.5 (среднее значение)
        return {month: 0.5 for month in values.keys()}
    
    min_val = min(values.values())
    max_val = max(values.values())
    
    if max_val == min_val:
        # Все значения одинаковы
        return {month: 0.5 for month in values.keys()}
    
    normalized = {}
    for month, value in values.items():
        if direction == "MAX":
            # Больше = лучше: нормализуем к [0, 1]
            normalized[month] = (value - min_val) / (max_val - min_val)
        else:  # direction == "MIN"
            # Меньше = лучше: инвертируем нормализацию
            normalized[month] = (max_val - value) / (max_val - min_val)
    
    return normalized
```

---

## Обработка edge cases

### Случай 1: Только один месяц с данными
- Нормализация невозможна (деление на 0)
- Решение: Возвращаем нормализованное значение 0.5 (среднее)
- Ранг = 1, лучший месяц = этот месяц ✅

### Случай 2: Все значения одинаковы
- min = max, деление на 0
- Решение: Возвращаем нормализованное значение 0.5 для всех месяцев
- Все месяцы получают ранг 1 ✅

### Случай 3: Отрицательные значения (прирост)
- Нормализация работает корректно
- Пример: min=-500, max=2000 → нормализация к [0, 1] ✅

### Случай 4: Частичные данные (есть OD, но нет RA и PS)
- Score рассчитывается только по имеющимся показателям
- Веса не нужно нормализовать, так как сравниваем месяцы у одного КМ ✅

---

## Выводы по Варианту 3

1. ✅ **Учитывает разные направления** для каждого показателя (OD=MAX, RA=MIN, PS=MAX)
2. ✅ **Учитывает разные типы расчета** (факт, прирост по 2м, прирост по 3м) - они уже учтены в значениях
3. ✅ **Устраняет проблему разных масштабов** через нормализацию
4. ✅ **Работает с отрицательными значениями** (прирост может быть отрицательным)
5. ⚠️ **Сложнее в реализации** (нужна нормализация с учетом направления)
6. ⚠️ **Медленнее** варианта 1 (нормализация добавляет вычисления)

**Рекомендация:** Использовать Вариант 3, если нужны разные направления для разных показателей и сильно разные масштабы. В остальных случаях Вариант 1 проще и быстрее.

---

## Сравнительная таблица вариантов с учетом разных направлений

| Критерий | Вариант 1 (без нормализации) | Вариант 3 (с нормализацией) |
|----------|------------------------------|----------------------------|
| **Разные направления (OD=MAX, RA=MIN)** | ⚠️ Нужна инверсия значений RA перед суммированием | ✅ Автоматически через инверсию в нормализации |
| **Разные масштабы (факт=10000, прирост=-500)** | ⚠️ Проблема: факт доминирует | ✅ Решено: нормализация к [0,1] |
| **Разные типы расчета** | ✅ Работает (уже учтены в значениях) | ✅ Работает (уже учтены в значениях) |
| **Отрицательные значения** | ✅ Работает | ✅ Работает (нормализация корректна) |
| **Простота реализации** | ✅ Просто | ⚠️ Сложнее (нормализация) |
| **Производительность** | ✅ Быстро | ⚠️ Медленнее (нормализация) |
| **Понятность логики** | ✅ Понятно | ⚠️ Сложнее понять |
| **Обработка одного месяца** | ✅ Работает | ⚠️ Нужна обработка (деление на 0) |

---

## Модификация Варианта 1 для учета разных направлений

**Если использовать Вариант 1, но учесть разные направления:**

```python
# Для каждого КМ и каждого месяца
for km in all_km:
    for month in months_with_data:
        od_value = OD(month)
        ra_value = RA(month)
        ps_value = PS(month)
        
        # Инверсия для MIN показателей
        if od_direction == "MIN":
            od_value = -od_value  # Инвертируем для суммирования
        if ra_direction == "MIN":
            ra_value = -ra_value  # Инвертируем для суммирования
        if ps_direction == "MIN":
            ps_value = -ps_value  # Инвертируем для суммирования
        
        score = (
            od_value * weight_OD + 
            ra_value * weight_RA + 
            ps_value * weight_PS
        )
        scores[km][month] = score

# После инверсии всегда MAX (больше = лучше)
sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
```

**Преимущества:**
- ✅ Проще, чем Вариант 3 (нет нормализации)
- ✅ Быстрее, чем Вариант 3
- ✅ Учитывает разные направления

**Недостатки:**
- ⚠️ Проблема с разными масштабами остается (факт=10000 доминирует над приростом=-500)
- ⚠️ Инверсия может привести к проблемам, если значения сильно различаются

**Пример проблемы:**
```
OD (MAX): M-1=10000, M-2=20000
RA (MIN): M-1=500, M-2=300

После инверсии RA:
RA: M-1=-500, M-2=-300

Score(M-1) = 10000*0.33 + (-500)*0.33 = 3135
Score(M-2) = 20000*0.33 + (-300)*0.33 = 6501

Проблема: OD доминирует, RA почти не влияет!
```

**Решение:** Использовать Вариант 3 с нормализацией.

---

## Итоговая рекомендация

### Если все показатели имеют одно направление (все MAX или все MIN):
**→ Использовать Вариант 1** (проще и быстрее)

### Если показатели имеют разные направления (OD=MAX, RA=MIN, PS=MAX):
**→ Использовать Вариант 3** (нормализация учитывает направления и масштабы)

### Если показатели имеют разные направления, но сопоставимые масштабы:
**→ Можно использовать модифицированный Вариант 1** (инверсия значений для MIN)

---

## Параметры конфигурации для Варианта 3

### Добавить в DefaultsConfig:

```python
@dataclass
class DefaultsConfig:
    # ... существующие параметры ...
    
    # Направление показателя для расчета лучшего месяца
    # "MAX" - большее значение лучше, "MIN" - меньшее значение лучше
    indicator_direction: str = "MAX"  # По умолчанию для всех показателей
```

### Использование в конфигурации:

```python
# OD: прирост по 3 периодам, больше = лучше
configs["OD"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=3,
        indicator_direction="MAX",  # Больше = лучше
        weight=0.33,
        ...
    )
)

# RA: прирост по 2 месяцам, меньше = лучше (например, снижение долга)
configs["RA"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=2,
        indicator_direction="MIN",  # Меньше = лучше
        weight=0.33,
        ...
    )
)

# PS: факт, больше = лучше
configs["PS"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=1,
        indicator_direction="MAX",  # Больше = лучше
        weight=0.34,
        ...
    )
)
```

---

## Алгоритм выбора варианта

```
Есть разные направления для показателей?
├─ НЕТ → Вариант 1 (проще и быстрее)
└─ ДА → Есть сильно разные масштабы?
    ├─ НЕТ → Модифицированный Вариант 1 (инверсия)
    └─ ДА → Вариант 3 (нормализация)
```

---

## Заключение

**Вариант 3** позволяет учесть:
1. ✅ **Разные направления** для каждого показателя (OD=MAX, RA=MIN, PS=MAX)
2. ✅ **Разные типы расчета** (факт, прирост по 2м, прирост по 3м) - уже учтены в значениях
3. ✅ **Разные масштабы** (факт=10000, прирост=-500) - решено через нормализацию
4. ✅ **Отрицательные значения** - нормализация работает корректно

**Реализация:** Требует добавления параметра `indicator_direction` в конфигурацию и функции нормализации с учетом направления.

**Рекомендация:** Использовать Вариант 3, если нужны разные направления для разных показателей. В остальных случаях Вариант 1 проще и быстрее.

---

## Рекомендация

**Рекомендую Вариант 1 (Горизонтальный ранг для каждого КМ)** по следующим причинам:

1. **Простота:** Не нужна нормализация, логика понятна
2. **Корректность:** Сравниваем месяцы у конкретного КМ, а не КМ между собой
3. **Гибкость:** Легко учитывать направление показателя (MAX или MIN)
4. **Производительность:** Быстрее, чем варианты с нормализацией

### Детальный алгоритм (Вариант 1)

**Шаг 1: Расчет взвешенной суммы для каждого месяца**
```python
# Для каждого КМ и каждого месяца
for km in all_km:
    for month in [1, 2, ..., 12]:
        score = (
            OD(month) * weight_OD + 
            RA(month) * weight_RA + 
            PS(month) * weight_PS
        )
        scores[km][month] = score
```

**Шаг 2: Расчет горизонтального ранга для каждого КМ**
```python
# Для каждого КМ
for km in all_km:
    km_scores = scores[km]  # Словарь {month: score}
    
    if best_direction == "MAX":
        # Больше = лучше, ранг 1 = максимальный Score
        sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
    else:  # best_direction == "MIN"
        # Меньше = лучше, ранг 1 = минимальный Score
        sorted_months = sorted(km_scores.items(), key=lambda x: x[1])
    
    # Присваиваем ранги (с учетом одинаковых значений)
    rank = 1
    prev_score = None
    for month, score in sorted_months:
        if prev_score is not None and score != prev_score:
            rank += 1
        ranks[km][month] = rank
        prev_score = score
```

**Шаг 3: Выбор лучшего месяца**
```python
# Для каждого КМ выбираем месяц с рангом 1
for km in all_km:
    best_months = [month for month, rank in ranks[km].items() if rank == 1]
    best_month[km] = ", ".join(sorted(best_months))
```

---

## Параметры конфигурации

### Новый параметр: `best_direction`
Добавить в `DefaultsConfig`:
```python
best_direction: str = "MAX"  # "MAX" - большее значение лучше, "MIN" - меньшее значение лучше
```

**Использование:**
- `best_direction="MAX"`: Выбираем месяц с максимальной взвешенной суммой показателей
- `best_direction="MIN"`: Выбираем месяц с минимальной взвешенной суммой показателей

**По умолчанию:** `"MAX"` (больше = лучше)

---

## Сравнение подходов

| Критерий | Текущий (вертикальный ранг) | Вариант 1 (горизонтальный ранг) | Вариант 2 (нормализация) | Вариант 3 (нормализация + ранг) |
|----------|----------------------------|----------------------------------|---------------------------|----------------------------------|
| **Корректность** | ❌ Сравнивает с другими КМ | ✅ Сравнивает месяцы у КМ | ✅ Сравнивает месяцы у КМ | ✅ Сравнивает месяцы у КМ |
| **Учет направления** | ❌ Всегда MIN | ✅ MAX или MIN | ✅ MAX или MIN | ✅ MAX или MIN |
| **Простота** | ✅ Просто | ✅ Просто | ⚠️ Средне | ❌ Сложно |
| **Производительность** | ✅ Быстро | ✅ Быстро | ⚠️ Средне | ❌ Медленно |
| **Устойчивость к масштабам** | ✅ Есть (ранги) | ✅ Есть (сравнение только у КМ) | ✅ Есть (нормализация) | ✅ Есть (нормализация) |
| **Проблема с одним месяцем** | ✅ Нет | ✅ Нет | ❌ Деление на 0 | ❌ Деление на 0 |

---

## Итоговая рекомендация

**Использовать Вариант 1 (Горизонтальный ранг для каждого КМ)** с параметром `best_direction`.

**Изменения в коде:**
1. Убрать расчет вертикальных рангов для R_FIN (оставить только для отображения)
2. Добавить расчет горизонтального ранга для каждого КМ по месяцам
3. Добавить параметр `best_direction` в конфигурацию
4. Изменить логику выбора лучшего месяца на основе горизонтального ранга

**Преимущества:**
- ✅ Логика соответствует задаче (выбор лучшего месяца у КМ)
- ✅ Учитывает направление показателя (MAX или MIN)
- ✅ Проще в реализации и понимании
- ✅ Быстрее в выполнении

---

## Детальный пример работы нового алгоритма

### Исходные данные

**КМ А (табельный 12345):**
| Месяц | OD (тип расчета) | RA (тип расчета) | PS (тип расчета) |
|-------|------------------|-----------------|------------------|
| M-1   | 1000 (факт) | 500 (факт) | 300 (факт) |
| M-2   | 2000 (факт) | 800 (факт) | 400 (факт) |
| M-3   | 1500 (факт) | 600 (факт) | 350 (факт) |
| M-4   | 1800 (факт) | 700 (факт) | 380 (факт) |

**Примечание:** В реальных данных типы расчета могут различаться:
- OD может быть: факт (M-1), прирост по 2 месяцам (M-2), прирост по 3 периодам (M-3)
- RA может быть: факт (M-1), прирост по 2 месяцам (M-2), прирост по 3 периодам (M-3)
- PS может быть: факт (M-1), прирост по 2 месяцам (M-2), прирост по 3 периодам (M-3)

**Веса:** OD=0.33, RA=0.33, PS=0.34

### Шаг 1: Расчет взвешенной суммы Score для каждого месяца

**Важно:** Независимо от типа расчета показателя (факт, прирост по 2 месяцам, прирост по 3 периодам), мы используем итоговое значение показателя для расчета Score.

```
Score(M-1) = OD(M-1)*0.33 + RA(M-1)*0.33 + PS(M-1)*0.34
           = 1000*0.33 + 500*0.33 + 300*0.34 
           = 330 + 165 + 102 = 597

Score(M-2) = OD(M-2)*0.33 + RA(M-2)*0.33 + PS(M-2)*0.34
           = 2000*0.33 + 800*0.33 + 400*0.34 
           = 660 + 264 + 136 = 1060

Score(M-3) = OD(M-3)*0.33 + RA(M-3)*0.33 + PS(M-3)*0.34
           = 1500*0.33 + 600*0.33 + 350*0.34 
           = 495 + 198 + 119 = 812

Score(M-4) = OD(M-4)*0.33 + RA(M-4)*0.33 + PS(M-4)*0.34
           = 1800*0.33 + 700*0.33 + 380*0.34 
           = 594 + 231 + 129.2 = 954.2
```

**Примечание:** Тип расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) уже учтен при расчете значений OD, RA, PS на этапе подготовки данных (`prepare_calculated_data`). Мы используем итоговые значения этих показателей для расчета Score.

### Шаг 2: Расчет горизонтального ранга (best_direction="MAX")

```
Сортировка по убыванию Score:
  M-2: 1060 (ранг 1) ✅
  M-4: 954.2 (ранг 2)
  M-3: 812 (ранг 3)
  M-1: 597 (ранг 4)
```

**Лучший месяц:** M-2

### Шаг 3: Расчет горизонтального ранга (best_direction="MIN")

Если бы `best_direction="MIN"` (меньше = лучше):
```
Сортировка по возрастанию Score:
  M-1: 597 (ранг 1) ✅
  M-3: 812 (ранг 2)
  M-4: 954.2 (ранг 3)
  M-2: 1060 (ранг 4)
```

**Лучший месяц:** M-1

---

## Обработка одинаковых значений

**Пример:**
```
КМ Б:
  M-1: Score = 1000
  M-2: Score = 1000
  M-3: Score = 800
  M-4: Score = 1000
```

**Горизонтальный ранг (MAX, метод "skip"):**
```
  M-1: ранг 1
  M-2: ранг 1
  M-4: ранг 1
  M-3: ранг 4 (пропущены места 2 и 3)
```

**Лучший месяц:** "1, 2, 4" (все месяцы с рангом 1)

**Горизонтальный ранг (MAX, метод "dense"):**
```
  M-1: ранг 1
  M-2: ранг 1
  M-4: ранг 1
  M-3: ранг 2
```

**Лучший месяц:** "1, 2, 4" (все месяцы с рангом 1)

---

## Обработка отсутствующих данных

**Пример:**
```
КМ В:
  M-1: OD=1000, RA=500, PS=300  → Score = 597
  M-2: OD=NaN, RA=NaN, PS=NaN   → Score = NaN (пропускаем)
  M-3: OD=1500, RA=600, PS=350  → Score = 812
  M-4: OD=1800, RA=700, PS=380  → Score = 954.2
```

**Обработка:**
- Месяцы с NaN не участвуют в расчете ранга
- Ранг рассчитывается только для месяцев с данными
- Лучший месяц выбирается среди месяцев с данными

**Результат:**
```
  M-4: ранг 1 ✅
  M-3: ранг 2
  M-1: ранг 3
```

**Лучший месяц:** M-4

---

## Сравнение с текущим подходом

### Пример 1: КМ с разными результатами по месяцам

**КМ А:**
- M-1: OD=1000, RA=500, PS=300
- M-2: OD=2000, RA=800, PS=400

**Текущий подход (вертикальный ранг):**
- Предположим, что у всех КМ результаты примерно одинаковые
- R: OD (M-1) = 50, R: OD (M-2) = 50 (одинаковый ранг среди всех КМ)
- R_FIN (M-1) ≈ R_FIN (M-2) (не может различить лучший месяц)

**Новый подход (горизонтальный ранг):**
- Score(M-1) = 597, Score(M-2) = 1060
- Ранг: M-2 = 1, M-1 = 2
- **Лучший месяц: M-2** ✅

### Пример 2: КМ с лучшими результатами в одном месяце

**КМ Б (сильный КМ):**
- M-1: OD=5000, RA=3000, PS=2000
- M-2: OD=6000, RA=3500, PS=2500

**Текущий подход:**
- R: OD (M-1) = 1, R: OD (M-2) = 1 (всегда лучший ранг)
- R_FIN (M-1) ≈ R_FIN (M-2) (не может различить)

**Новый подход:**
- Score(M-1) = 3300, Score(M-2) = 3850
- Ранг: M-2 = 1, M-1 = 2
- **Лучший месяц: M-2** ✅

---

## Реализация в коде

### Псевдокод нового алгоритма

```python
def calculate_best_month_horizontal(calculated_df, config_manager):
    """
    Рассчитывает лучший месяц для каждого КМ на основе горизонтального ранга.
    
    ВАЖНО: Использует итоговые значения показателей (OD, RA, PS) для каждого месяца,
    независимо от типа расчета (факт, прирост по 2 месяцам, прирост по 3 периодам).
    Тип расчета уже учтен при подготовке данных в prepare_calculated_data.
    
    Args:
        calculated_df: DataFrame с расчетными данными (OD, RA, PS по месяцам)
                      Колонки имеют формат: "OD (M-1) [факт]", "RA (M-2) [M-2→M-1]", 
                      "PS (M-3) [M-3-2*M-2+M-1]" и т.д.
        config_manager: Менеджер конфигурации
    
    Returns:
        Series с лучшими месяцами для каждого КМ
    """
    # Получаем веса
    weight_od = config_manager.get_group_config("OD").defaults.weight
    weight_ra = config_manager.get_group_config("RA").defaults.weight
    weight_ps = config_manager.get_group_config("PS").defaults.weight
    
    # Получаем направление (MAX или MIN)
    best_direction = config_manager.get_global_setting("best_direction", "MAX")
    
    # Базовые колонки
    base_columns = ["Табельный", "ТБ", "ГОСБ", "ФИО"]
    
    # Группируем колонки по месяцам
    # ВАЖНО: Извлекаем группу (OD, RA, PS) и месяц из имени колонки
    # Формат колонок: "OD (M-1) [факт]", "RA (M-2) [M-2→M-1]", "PS (M-3) [M-3-2*M-2+M-1]"
    month_data = {}  # {month: {"OD": col_name, "RA": col_name, "PS": col_name}}
    
    for col in calculated_df.columns:
        if col in base_columns or col.startswith("R:"):
            continue
        
        # Извлекаем группу и месяц из имени колонки
        # Формат: "OD (M-1) [факт]" или "RA (M-2) [M-2→M-1]"
        match = re.search(r'^([A-Z]+)\s+\(M-(\d{1,2})\)', col)
        if match:
            group = match.group(1)  # OD, RA или PS
            month = int(match.group(2))  # 1-12
            
            if month not in month_data:
                month_data[month] = {}
            month_data[month][group] = col
    
    # Для каждого КМ рассчитываем Score по месяцам
    best_month_series = pd.Series("", index=calculated_df.index, dtype=str)
    
    for idx in calculated_df.index:
        km_scores = {}  # {month: score}
        
        for month in sorted(month_data.keys()):
            od_col = month_data[month].get("OD")
            ra_col = month_data[month].get("RA")
            ps_col = month_data[month].get("PS")
            
            score = 0.0
            has_data = False
            
            if od_col and od_col in calculated_df.columns:
                od_value = calculated_df.loc[idx, od_col]
                if pd.notna(od_value):
                    score += od_value * weight_od
                    has_data = True
            
            if ra_col and ra_col in calculated_df.columns:
                ra_value = calculated_df.loc[idx, ra_col]
                if pd.notna(ra_value):
                    score += ra_value * weight_ra
                    has_data = True
            
            if ps_col and ps_col in calculated_df.columns:
                ps_value = calculated_df.loc[idx, ps_col]
                if pd.notna(ps_value):
                    score += ps_value * weight_ps
                    has_data = True
            
            if has_data:
                km_scores[month] = score
        
        # Рассчитываем горизонтальный ранг для этого КМ
        if len(km_scores) > 0:
            if best_direction == "MAX":
                sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
            else:  # MIN
                sorted_months = sorted(km_scores.items(), key=lambda x: x[1])
            
            # Присваиваем ранги (с учетом одинаковых значений)
            ranks = {}
            rank = 1
            prev_score = None
            
            for month, score in sorted_months:
                if prev_score is not None and abs(score - prev_score) > 1e-10:  # Учитываем погрешность
                    rank += 1
                ranks[month] = rank
                prev_score = score
            
            # Выбираем месяцы с рангом 1
            best_months = [month for month, r in ranks.items() if r == 1]
            best_month_series.loc[idx] = ", ".join([str(m) for m in sorted(best_months)])
    
    return best_month_series
```

---

## Выводы

1. **Текущий подход некорректен** для задачи выбора лучшего месяца у КМ, так как сравнивает КМ между собой, а не месяцы у конкретного КМ.

2. **Новый подход (горизонтальный ранг)** корректно решает задачу, сравнивая месяцы у каждого КМ отдельно.

3. **Параметр `best_direction`** позволяет учитывать направление показателя (MAX или MIN).

4. **Алгоритм прост и эффективен**, не требует нормализации и работает быстрее текущего подхода.

5. **Рекомендуется внедрить** новый алгоритм для корректного определения лучшего месяца у каждого КМ.

---

## Конкретные рекомендации по реализации

### 1. Добавить параметр в конфигурацию

**В `DefaultsConfig` добавить:**
```python
# Направление для выбора лучшего месяца
best_direction: str = "MAX"  # "MAX" - большее значение лучше, "MIN" - меньшее значение лучше
```

**В конфигурации групп (OD, RA, PS) можно задать глобально:**
```python
# В ConfigManager добавить метод для получения глобального параметра
def get_global_setting(self, key: str, default: Any) -> Any:
    """Получает глобальную настройку (берется из первой группы или default)"""
    if self.groups:
        first_group = list(self.groups.keys())[0]
        defaults = self.groups[first_group].defaults
        return getattr(defaults, key, default)
    return default
```

### 2. Изменить метод `_calculate_final_ranks`

**Текущий метод:**
- Рассчитывает R_FIN на основе вертикальных рангов
- Выбирает месяц с минимальным R_FIN

**Новый метод:**
- Рассчитывает Score для каждого месяца (взвешенная сумма значений показателей)
- Рассчитывает горизонтальный ранг для каждого КМ по месяцам
- Выбирает месяц с рангом 1 (с учетом `best_direction`)

### 3. Сохранить вертикальные ранги для отображения

**Важно:** Вертикальные ранги (R: OD, R: RA, R: PS) можно оставить для отображения в Excel, но не использовать для расчета лучшего месяца.

**Альтернатива:** Можно убрать расчет R_FIN на основе вертикальных рангов, если он не нужен для отображения.

### 4. Оптимизация производительности

**Текущий подход:**
- Для каждого КМ и каждого месяца: поиск рангов в DataFrame
- Время: O(KM * Months * Groups)

**Новый подход:**
- Для каждого КМ: группировка по месяцам, расчет Score, сортировка
- Время: O(KM * Months * log(Months))
- **Ускорение:** За счет векторизации pandas

**Реализация:**
```python
# Векторизованный расчет Score для всех КМ одновременно
for month in sorted_months:
    od_col = month_data[month].get("OD")
    ra_col = month_data[month].get("RA")
    ps_col = month_data[month].get("PS")
    
    score = pd.Series(0.0, index=calculated_df.index)
    
    if od_col and od_col in calculated_df.columns:
        score += calculated_df[od_col].fillna(0) * weight_od
    
    if ra_col and ra_col in calculated_df.columns:
        score += calculated_df[ra_col].fillna(0) * weight_ra
    
    if ps_col and ps_col in calculated_df.columns:
        score += calculated_df[ps_col].fillna(0) * weight_ps
    
    scores[month] = score

# Горизонтальный ранг для каждого КМ (векторизовано через groupby)
for idx in calculated_df.index:
    km_scores = {month: scores[month].loc[idx] for month in sorted_months 
                 if pd.notna(scores[month].loc[idx]) and scores[month].loc[idx] != 0}
    
    if len(km_scores) > 0:
        # Сортировка и присвоение рангов
        ...
```

### 5. Обработка edge cases

**Случай 1: Только один месяц с данными**
- Ранг = 1, лучший месяц = этот месяц ✅

**Случай 2: Все месяцы с одинаковым Score**
- Все месяцы получают ранг 1, лучший месяц = все месяцы через запятую ✅

**Случай 3: Нет данных ни в одном месяце**
- Лучший месяц = пустая строка ✅

**Случай 4: Частичные данные (есть OD, но нет RA и PS)**
- Score рассчитывается только по имеющимся показателям
- Веса нормализуются: если есть только OD, то weight_od = 1.0 ✅

### 6. Обратная совместимость

**Вариант А: Полная замена**
- Убрать расчет R_FIN на основе вертикальных рангов
- Использовать только горизонтальный ранг

**Вариант Б: Гибридный подход (рекомендуется)**
- Оставить расчет R_FIN для отображения (если нужен)
- Добавить новый расчет лучшего месяца на основе горизонтального ранга
- Добавить параметр для выбора метода (старый/новый)

**Рекомендация:** Вариант А (полная замена), так как текущий подход некорректен для задачи.

---

## Итоговый план действий

1. ✅ **Анализ выполнен** - выявлены проблемы текущего подхода
2. ⏳ **Добавить параметр `best_direction`** в `DefaultsConfig`
3. ⏳ **Переписать метод `_calculate_final_ranks`** для использования горизонтального ранга
4. ⏳ **Убрать расчет R_FIN** на основе вертикальных рангов (или оставить для отображения)
5. ⏳ **Учесть разные типы расчета показателей:**
   - Типы расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) уже учтены в значениях показателей
   - При расчете Score используем итоговые значения независимо от типа расчета
   - Дополнительная обработка не требуется
6. ⏳ **Протестировать** на реальных данных с разными типами расчета (OD, RA, PS могут иметь разные типы)
7. ⏳ **Обновить документацию** (README.md)

**Ожидаемый результат:**
- Корректное определение лучшего месяца для каждого КМ
- Учет направления показателя (MAX или MIN)
- Улучшенная производительность
- Более понятная логика

---

## Визуальное сравнение подходов

### Текущий подход (ВЕРТИКАЛЬНЫЙ ранг)

```
КМ А:                    КМ Б:                    КМ В:
M-1: OD=1000, RA=500     M-1: OD=500, RA=300      M-1: OD=2000, RA=1000
M-2: OD=2000, RA=800     M-2: OD=1500, RA=600     M-2: OD=3000, RA=1500

Вертикальный ранг (среди всех КМ):
  R: OD (M-1): КМ А=2, КМ Б=3, КМ В=1
  R: OD (M-2): КМ А=2, КМ Б=3, КМ В=1
  
R_FIN (M-1): КМ А=0.66, КМ Б=0.99, КМ В=0.33
R_FIN (M-2): КМ А=0.66, КМ Б=0.99, КМ В=0.33

Лучший месяц:
  КМ А: M-1 или M-2 (одинаково) ❌ НЕПРАВИЛЬНО
  КМ Б: M-1 или M-2 (одинаково) ❌ НЕПРАВИЛЬНО
  КМ В: M-1 или M-2 (одинаково) ❌ НЕПРАВИЛЬНО
```

**Проблема:** Не может различить лучший месяц, так как сравнивает с другими КМ.

---

### Новый подход (ГОРИЗОНТАЛЬНЫЙ ранг)

```
КМ А:                    КМ Б:                    КМ В:
M-1: OD=1000, RA=500     M-1: OD=500, RA=300      M-1: OD=2000, RA=1000
M-2: OD=2000, RA=800     M-2: OD=1500, RA=600     M-2: OD=3000, RA=1500

Горизонтальный ранг (среди месяцев у КМ):
  КМ А: Score(M-1)=597, Score(M-2)=1060 → M-2 лучше ✅
  КМ Б: Score(M-1)=330, Score(M-2)=990 → M-2 лучше ✅
  КМ В: Score(M-1)=990, Score(M-2)=1485 → M-2 лучше ✅

Лучший месяц:
  КМ А: M-2 ✅ ПРАВИЛЬНО
  КМ Б: M-2 ✅ ПРАВИЛЬНО
  КМ В: M-2 ✅ ПРАВИЛЬНО
```

**Преимущество:** Корректно определяет лучший месяц для каждого КМ, сравнивая его собственные результаты.

---

## Матрица сравнения

| Аспект | Текущий (вертикальный) | Новый (горизонтальный) |
|--------|------------------------|------------------------|
| **Что сравнивается** | КМ между собой | Месяцы у КМ |
| **Корректность** | ❌ Некорректно | ✅ Корректно |
| **Учет направления** | ❌ Всегда MIN | ✅ MAX или MIN |
| **Производительность** | ⚠️ Средне | ✅ Быстро |
| **Понятность** | ⚠️ Сложно | ✅ Просто |
| **Гибкость** | ❌ Нет | ✅ Есть (best_direction) |

---

## Заключение

Текущий подход использует **вертикальный ранг** (сравнение КМ между собой), что некорректно для задачи выбора лучшего месяца у конкретного КМ.

**Новый подход** использует **горизонтальный ранг** (сравнение месяцев у конкретного КМ), что корректно решает задачу.

**Рекомендация:** Внедрить новый алгоритм с горизонтальным рангом и параметром `best_direction` для учета направления показателя.

---

## Ответы на возможные вопросы

### Вопрос 1: Зачем нужен вертикальный ранг, если он не используется для выбора лучшего месяца?

**Ответ:** Вертикальный ранг можно оставить для отображения в Excel, чтобы видеть, как КМ выглядит на фоне других КМ. Но для выбора лучшего месяца он не нужен и даже мешает.

**Рекомендация:** Оставить вертикальные ранги (R: OD, R: RA, R: PS) для отображения, но не использовать их для расчета лучшего месяца.

### Вопрос 2: Что делать, если показатели в разных масштабах (OD=10000, RA=1000, PS=100)?

**Ответ:** При горизонтальном ранге это не проблема, так как мы сравниваем месяцы у одного КМ. Если у КМ в M-1: OD=10000, RA=1000, PS=100, а в M-2: OD=20000, RA=2000, PS=200, то Score(M-2) будет больше Score(M-1) пропорционально, и M-2 будет выбран как лучший месяц.

**Важно:** Разные типы расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) могут давать значения в разных масштабах:
- Факт: обычно большие значения (например, 10000)
- Прирост по 2 месяцам: средние значения (например, 1000)
- Прирост по 3 периодам: могут быть отрицательные значения (например, -500)

Это нормально, так как мы сравниваем месяцы у одного КМ, и веса (weight_OD, weight_RA, weight_PS) уже учитывают важность каждого показателя.

**Если нужна нормализация:** Можно добавить опциональную нормализацию показателей перед расчетом Score, но это усложнит логику и обычно не требуется.

### Вопрос 3: Как обрабатывать случаи, когда у КМ есть данные только для одного показателя?

**Ответ:** Score рассчитывается только по имеющимся показателям. Например, если есть только OD, то Score = OD * weight_OD. Веса не нужно нормализовать, так как мы сравниваем только месяцы у одного КМ.

**Пример:**
```
КМ А:
  M-1: OD=1000, RA=NaN, PS=NaN → Score = 1000 * 0.33 = 330
  M-2: OD=2000, RA=NaN, PS=NaN → Score = 2000 * 0.33 = 660
Лучший месяц: M-2 ✅
```

### Вопрос 4: Что делать, если все показатели имеют разные направления (OD=MAX, RA=MIN, PS=MAX)?

**Ответ:** Это сложный случай. В текущей реализации все показатели имеют одно направление (определяется через `rank_order` в конфигурации для расчета вертикальных рангов). 

**Важно:** При расчете Score мы просто суммируем значения показателей с весами. Направление (MAX или MIN) учитывается только при выборе лучшего месяца через параметр `best_direction`:
- Если `best_direction="MAX"`: выбираем месяц с максимальным Score
- Если `best_direction="MIN"`: выбираем месяц с минимальным Score

**Варианты решения:**
1. **Простой подход (рекомендуется):** Все показатели имеют одно направление (MAX или MIN), определяется глобально через `best_direction`. Если показатель должен быть MIN (например, прирост должен быть отрицательным), то его значение уже будет отрицательным в Score, и при `best_direction="MIN"` будет выбран месяц с минимальным Score.
2. **Расширенный подход:** Можно добавить параметр направления для каждого показателя отдельно, но это усложнит логику и обычно не требуется.

**Рекомендация:** Начать с простого подхода (одно направление для всех показателей через `best_direction`), при необходимости расширить.

**Пример:** Если прирост по 2 месяцам должен быть отрицательным (меньше = лучше), то:
- Значение прироста уже будет отрицательным (например, -500)
- Score будет меньше для месяцев с отрицательным приростом
- При `best_direction="MIN"` будет выбран месяц с минимальным Score (наименьший прирост = лучший результат)

### Вопрос 5: Нужно ли сохранять колонки R_FIN на основе вертикальных рангов?

**Ответ:** Зависит от требований. Если R_FIN нужен для анализа (например, "как КМ выглядит на фоне других"), то можно оставить. Если не нужен, можно убрать для упрощения.

**Рекомендация:** Убрать расчет R_FIN на основе вертикальных рангов, так как он некорректен для задачи. Если нужен анализ "на фоне других", можно использовать вертикальные ранги (R: OD, R: RA, R: PS) напрямую.

### Вопрос 6: Как обрабатывать одинаковые значения Score у разных месяцев?

**Ответ:** Используется тот же метод, что и для вертикальных рангов:
- **"skip"**: Пропуск мест (1, 2, 3, 3, 3, 6, 7)
- **"dense"**: Плотный ранг (1, 2, 3, 3, 3, 4, 5, 6, 7)

Все месяцы с одинаковым Score получают одинаковый ранг, и все они считаются "лучшими".

**Пример:**
```
КМ А:
  M-1: Score = 1000 (ранг 1)
  M-2: Score = 1000 (ранг 1)
  M-3: Score = 800 (ранг 3)
Лучший месяц: "1, 2" ✅
```

### Вопрос 7: Влияет ли новый подход на производительность?

**Ответ:** Новый подход **быстрее** текущего, так как:
- Не нужно рассчитывать R_FIN для каждого месяца отдельно
- Используется векторизация pandas для расчета Score
- Горизонтальный ранг рассчитывается только для месяцев с данными

**Ожидаемое ускорение:** 1.5-2x (за счет векторизации и упрощения логики).

---

## Финальные рекомендации

1. ✅ **Внедрить горизонтальный ранг** для выбора лучшего месяца
2. ✅ **Добавить параметр `best_direction`** (MAX или MIN)
3. ✅ **Убрать расчет R_FIN** на основе вертикальных рангов (или оставить для отображения)
4. ✅ **Сохранить вертикальные ранги** (R: OD, R: RA, R: PS) для отображения в Excel
5. ✅ **Протестировать** на реальных данных перед внедрением

**Преимущества нового подхода:**
- ✅ Корректность: сравнивает месяцы у КМ, а не КМ между собой
- ✅ Гибкость: учитывает направление показателя (MAX или MIN)
- ✅ Простота: логика понятна и легко реализуется
- ✅ Производительность: быстрее текущего подхода

---

## Пример реализации (Python код)

### Структура нового метода

```python
def _calculate_best_month_horizontal(self, calculated_df: pd.DataFrame, config_manager) -> pd.Series:
    """
    Рассчитывает лучший месяц для каждого КМ на основе горизонтального ранга.
    
    Алгоритм:
    1. Для каждого КМ и каждого месяца рассчитываем Score = OD*w_OD + RA*w_RA + PS*w_PS
    2. Для каждого КМ рассчитываем горизонтальный ранг по месяцам
    3. Выбираем месяц с рангом 1 (с учетом best_direction)
    
    Args:
        calculated_df: DataFrame с расчетными данными
        config_manager: Менеджер конфигурации
    
    Returns:
        Series с лучшими месяцами для каждого КМ (формат: "1, 3" или "2")
    """
    # Получаем веса
    weight_od = config_manager.get_group_config("OD").defaults.weight if "OD" in config_manager.groups else 0.33
    weight_ra = config_manager.get_group_config("RA").defaults.weight if "RA" in config_manager.groups else 0.33
    weight_ps = config_manager.get_group_config("PS").defaults.weight if "PS" in config_manager.groups else 0.34
    
    # Получаем направление (MAX или MIN)
    # Можно добавить в конфигурацию или использовать глобальный параметр
    best_direction = "MAX"  # По умолчанию: больше = лучше
    
    # Базовые колонки
    base_columns = ["Табельный", "ТБ", "ГОСБ", "ФИО"]
    
    # Группируем колонки по месяцам
    month_data = {}  # {month: {"OD": col_name, "RA": col_name, "PS": col_name}}
    
    for col in calculated_df.columns:
        if col in base_columns or col.startswith("R:"):
            continue
        
        match = re.search(r'^([A-Z]+)\s+\(M-(\d{1,2})\)', col)
        if match:
            group = match.group(1)
            month = int(match.group(2))
            
            if month not in month_data:
                month_data[month] = {}
            month_data[month][group] = col
    
    # Для каждого КМ рассчитываем Score по месяцам и выбираем лучший
    best_month_series = pd.Series("", index=calculated_df.index, dtype=str)
    
    for idx in calculated_df.index:
        km_scores = {}  # {month: score}
        
        # Шаг 1: Расчет Score для каждого месяца
        # ВАЖНО: Используем итоговые значения показателей независимо от типа расчета
        # Тип расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) уже учтен
        # в значениях OD, RA, PS при подготовке данных в prepare_calculated_data
        for month in sorted(month_data.keys()):
            od_col = month_data[month].get("OD")
            ra_col = month_data[month].get("RA")
            ps_col = month_data[month].get("PS")
            
            score = 0.0
            has_data = False
            
            # Используем значение OD независимо от типа расчета (факт, прирост по 2м, прирост по 3м)
            if od_col and od_col in calculated_df.columns:
                od_value = calculated_df.loc[idx, od_col]
                if pd.notna(od_value) and od_value != 0:
                    score += float(od_value) * weight_od
                    has_data = True
            
            # Используем значение RA независимо от типа расчета (факт, прирост по 2м, прирост по 3м)
            if ra_col and ra_col in calculated_df.columns:
                ra_value = calculated_df.loc[idx, ra_col]
                if pd.notna(ra_value) and ra_value != 0:
                    score += float(ra_value) * weight_ra
                    has_data = True
            
            # Используем значение PS независимо от типа расчета (факт, прирост по 2м, прирост по 3м)
            if ps_col and ps_col in calculated_df.columns:
                ps_value = calculated_df.loc[idx, ps_col]
                if pd.notna(ps_value) and ps_value != 0:
                    score += float(ps_value) * weight_ps
                    has_data = True
            
            if has_data:
                km_scores[month] = score
        
        # Шаг 2: Расчет горизонтального ранга для этого КМ
        if len(km_scores) > 0:
            # Сортируем месяцы по Score
            if best_direction == "MAX":
                # Больше = лучше, ранг 1 = максимальный Score
                sorted_months = sorted(km_scores.items(), key=lambda x: x[1], reverse=True)
            else:  # best_direction == "MIN"
                # Меньше = лучше, ранг 1 = минимальный Score
                sorted_months = sorted(km_scores.items(), key=lambda x: x[1])
            
            # Присваиваем ранги (с учетом одинаковых значений)
            ranks = {}
            rank = 1
            prev_score = None
            
            for month, score in sorted_months:
                # Если значение отличается от предыдущего, увеличиваем ранг
                if prev_score is not None and abs(score - prev_score) > 1e-10:
                    rank += 1
                ranks[month] = rank
                prev_score = score
            
            # Шаг 3: Выбираем месяцы с рангом 1
            best_months = [month for month, r in ranks.items() if r == 1]
            if best_months:
                best_month_series.loc[idx] = ", ".join([str(m) for m in sorted(best_months)])
    
    return best_month_series
```

### Интеграция в существующий код

**Заменить в методе `_calculate_final_ranks`:**
```python
# Старый код (убрать):
# Расчет R_FIN на основе вертикальных рангов
# Выбор месяца с минимальным R_FIN

# Новый код (добавить):
# Расчет лучшего месяца на основе горизонтального ранга
best_month_series = self._calculate_best_month_horizontal(calculated_df, config_manager)
calculated_df["Лучший месяц"] = best_month_series
```

### Оптимизация через векторизацию

**Для улучшения производительности можно векторизовать расчет Score:**
```python
# Векторизованный расчет Score для всех КМ одновременно
scores_by_month = {}  # {month: Series with scores for all KM}

for month in sorted(month_data.keys()):
    score_series = pd.Series(0.0, index=calculated_df.index)
    
    od_col = month_data[month].get("OD")
    ra_col = month_data[month].get("RA")
    ps_col = month_data[month].get("PS")
    
    # ВАЖНО: Используем итоговые значения показателей независимо от типа расчета
    # Тип расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) уже учтен
    # в значениях при подготовке данных в prepare_calculated_data
    
    if od_col and od_col in calculated_df.columns:
        # Значение OD уже содержит итоговый результат (факт, прирост по 2м, прирост по 3м)
        score_series += calculated_df[od_col].fillna(0) * weight_od
    
    if ra_col and ra_col in calculated_df.columns:
        # Значение RA уже содержит итоговый результат (факт, прирост по 2м, прирост по 3м)
        score_series += calculated_df[ra_col].fillna(0) * weight_ra
    
    if ps_col and ps_col in calculated_df.columns:
        # Значение PS уже содержит итоговый результат (факт, прирост по 2м, прирост по 3м)
        score_series += calculated_df[ps_col].fillna(0) * weight_ps
    
    scores_by_month[month] = score_series

# Затем для каждого КМ рассчитываем горизонтальный ранг
for idx in calculated_df.index:
    km_scores = {month: scores_by_month[month].loc[idx] 
                 for month in sorted_months 
                 if pd.notna(scores_by_month[month].loc[idx]) and scores_by_month[month].loc[idx] != 0}
    # ... остальная логика
```

**Преимущество:** Векторизация ускоряет расчет Score в 10-100 раз для больших данных.

---

## Важные замечания о типах расчета показателей

### Типы расчета для каждого показателя

**Каждый показатель (OD, RA, PS) может иметь свой тип расчета для каждого месяца:**

1. **Факт (calculation_type=1):**
   - Просто сумма данных по табельному номеру в указанный месяц
   - Пример: OD (M-1) = сумма всех значений OD для КМ в январе

2. **Прирост по 2 месяцам (calculation_type=2):**
   - Текущий месяц - предыдущий месяц
   - Пример: OD (M-2) = OD в феврале - OD в январе
   - Может быть положительным (рост) или отрицательным (падение)

3. **Прирост по 3 периодам (calculation_type=3):**
   - М-N = М-N - 2*М-(N-1) + М-(N-2)
   - Пример: OD (M-3) = OD в марте - 2*OD в феврале + OD в январе
   - Может быть положительным или отрицательным

### Влияние на расчет Score

**Важно:** Независимо от типа расчета, мы используем итоговое значение показателя для расчета Score:

```
Score(M-X) = OD(M-X) * weight_OD + RA(M-X) * weight_RA + PS(M-X) * weight_PS
```

Где:
- `OD(M-X)` - итоговое значение OD в месяце X (может быть факт, прирост по 2м, прирост по 3м)
- `RA(M-X)` - итоговое значение RA в месяце X (может быть факт, прирост по 2м, прирост по 3м)
- `PS(M-X)` - итоговое значение PS в месяце X (может быть факт, прирост по 2м, прирост по 3м)

**Пример с разными типами расчета:**
```
КМ А:
  M-1: OD=1000 (факт), RA=500 (факт), PS=300 (факт)
       Score = 1000*0.33 + 500*0.33 + 300*0.34 = 597
  
  M-2: OD=500 (прирост по 2м), RA=300 (прирост по 2м), PS=100 (прирост по 2м)
       Score = 500*0.33 + 300*0.33 + 100*0.34 = 297
  
  M-3: OD=-200 (прирост по 3м), RA=-100 (прирост по 3м), PS=-50 (прирост по 3м)
       Score = -200*0.33 + (-100)*0.33 + (-50)*0.34 = -99
```

**При `best_direction="MAX"`:**
- Лучший месяц: M-1 (Score=597) ✅

**При `best_direction="MIN"`:**
- Лучший месяц: M-3 (Score=-99) ✅

### Конфигурация типов расчета

**Типы расчета задаются в конфигурации для каждой группы отдельно:**

```python
# Конфигурация OD
configs["OD"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=3,  # Прирост по 3 периодам для всех месяцев OD
        ...
    )
)

# Конфигурация RA
configs["RA"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=2,  # Прирост по 2 месяцам для всех месяцев RA
        ...
    )
)

# Конфигурация PS
configs["PS"] = GroupConfig(
    defaults=DefaultsConfig(
        calculation_type=1,  # Факт для всех месяцев PS
        ...
    )
)
```

**Также можно задать тип расчета для конкретного файла:**

```python
FileItem(
    key="OD_01",
    file_name="M-1_OD.xlsx",
    calculation_type=1,  # Для этого файла использовать факт (переопределяет default)
    ...
)
```

---

## Итоговая таблица сравнения

| Критерий | Текущий подход | Новый подход (рекомендуется) |
|----------|----------------|------------------------------|
| **Тип ранга** | Вертикальный (среди всех КМ) | Горизонтальный (среди месяцев у КМ) |
| **Корректность** | ❌ Некорректно для задачи | ✅ Корректно для задачи |
| **Учет направления** | ❌ Всегда MIN | ✅ MAX или MIN (настраивается) |
| **Простота логики** | ⚠️ Сложно понять | ✅ Просто и понятно |
| **Производительность** | ⚠️ Средне | ✅ Быстро (векторизация) |
| **Гибкость** | ❌ Нет | ✅ Есть (best_direction) |
| **Обработка одинаковых значений** | ✅ Есть | ✅ Есть |
| **Обработка отсутствующих данных** | ✅ Есть | ✅ Есть |
| **Обработка одного месяца** | ✅ Есть | ✅ Есть |
| **Разные масштабы показателей** | ✅ Не проблема (ранги) | ✅ Не проблема (сравнение у КМ) |

---

## Финальное резюме

### Проблема
Текущий алгоритм использует **вертикальный ранг** (сравнение КМ между собой), что некорректно для задачи выбора лучшего месяца у конкретного КМ.

### Решение
Использовать **горизонтальный ранг** (сравнение месяцев у конкретного КМ) с параметром `best_direction` (MAX или MIN).

### Преимущества
1. ✅ **Корректность:** Сравнивает месяцы у КМ, а не КМ между собой
2. ✅ **Гибкость:** Учитывает направление показателя (MAX или MIN)
3. ✅ **Простота:** Логика понятна и легко реализуется
4. ✅ **Производительность:** Быстрее текущего подхода

### План действий
1. Добавить параметр `best_direction` в конфигурацию
2. Переписать метод `_calculate_final_ranks` для использования горизонтального ранга
3. Убрать расчет R_FIN на основе вертикальных рангов (или оставить для отображения)
4. **Учесть разные типы расчета показателей:**
   - Типы расчета (факт, прирост по 2 месяцам, прирост по 3 периодам) уже учтены в значениях показателей при подготовке данных в `prepare_calculated_data`
   - При расчете Score используем итоговые значения показателей независимо от типа расчета
   - Дополнительная обработка не требуется
5. Протестировать на реальных данных с разными типами расчета (OD, RA, PS могут иметь разные типы)
6. Обновить документацию

**Рекомендация:** Внедрить новый алгоритм как можно скорее, так как текущий подход дает некорректные результаты.

**Важно:** Новый алгоритм работает корректно с любыми типами расчета показателей, так как использует итоговые значения, которые уже рассчитаны с учетом типа расчета в методе `prepare_calculated_data`.

---

## Дополнительные замечания о типах расчета

### Влияние типов расчета на выбор лучшего месяца

**Важно понимать:** Разные типы расчета могут давать значения в разных масштабах и с разными знаками:

1. **Факт (calculation_type=1):**
   - Всегда положительные значения (сумма данных)
   - Обычно большие значения (например, 1000-10000)

2. **Прирост по 2 месяцам (calculation_type=2):**
   - Могут быть положительные (рост) или отрицательные (падение)
   - Обычно средние значения (например, -500 до +2000)

3. **Прирост по 3 периодам (calculation_type=3):**
   - Могут быть положительные или отрицательные
   - Могут быть в разных масштабах в зависимости от данных

**Пример:**
```
КМ А:
  M-1: OD=1000 (факт), RA=500 (факт), PS=300 (факт)
       Score = 1000*0.33 + 500*0.33 + 300*0.34 = 597
  
  M-2: OD=200 (прирост по 2м), RA=100 (прирост по 2м), PS=50 (прирост по 2м)
       Score = 200*0.33 + 100*0.33 + 50*0.34 = 99
  
  M-3: OD=-50 (прирост по 3м), RA=-25 (прирост по 3м), PS=-10 (прирост по 3м)
       Score = -50*0.33 + (-25)*0.33 + (-10)*0.34 = -28.05
```

**При `best_direction="MAX"`:**
- Лучший месяц: M-1 (Score=597) - месяц с фактом (наибольший Score)

**При `best_direction="MIN"`:**
- Лучший месяц: M-3 (Score=-28.05) - месяц с наименьшим приростом (наименьший Score)

**Вывод:** Тип расчета влияет на значения Score, но алгоритм выбора лучшего месяца работает корректно независимо от типов расчета, так как сравнивает месяцы у одного КМ.

### Рекомендации по настройке типов расчета

1. **Для сравнения месяцев у КМ:**
   - Используйте одинаковые типы расчета для всех месяцев одного показателя
   - Например: все месяцы OD - факт, все месяцы RA - прирост по 2м, все месяцы PS - прирост по 3м

2. **Для смешанных типов:**
   - Можно использовать разные типы для разных месяцев, но это усложнит интерпретацию результатов
   - Рекомендуется использовать одинаковые типы для всех месяцев одного показателя

3. **Для выбора направления (`best_direction`):**
   - Если используете факт: обычно `best_direction="MAX"` (больше = лучше)
   - Если используете прирост: зависит от задачи:
     - Прирост должен быть положительным (рост) → `best_direction="MAX"`
     - Прирост должен быть отрицательным (снижение) → `best_direction="MIN"`
